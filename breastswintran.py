# -*- coding: utf-8 -*-
"""breastSwinTran.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HlteIxDJyMZAkxOMpTvRKPCSia_7_KPj
"""

from google.colab import drive
drive._mount('/content/drive')

!sudo add-apt-repository -y ppa:alessandro-strada/ppa 2>&1 > /dev/null
!sudo apt-get update -qq 2>&1 > /dev/null
!sudo apt -y install -qq google-drive-ocamlfuse 2>&1 > /dev/null
!google-drive-ocamlfuse

# Commented out IPython magic to ensure Python compatibility.
!sudo apt-get install -qq w3m # to act as web browser 
!xdg-settings set default-web-browser w3m.desktop # to set default browser
# %cd /content
!mkdir drive
# %cd drive
!mkdir MyDrive
# %cd ..
# %cd ..
!google-drive-ocamlfuse /content/drive/MyDrive

!pip install vit-keras
!pip install tensorflow-addons

!git clone https://github.com/rishigami/Swin-Transformer-TF.git

import tensorflow as tf
import os
import sys
sys.path.append('/content/Swin-Transformer-TF')
from swintransformer import SwinTransformer
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import RepeatedStratifiedKFold, train_test_split
#from vit_keras import vit, utils, visualize

import cv2
from vit_keras import vit, utils, visualize

data_dir = '/content/drive/MyDrive/Datasets/Dataset_BUSI_with_GT'
normal_path = os.path.join(data_dir, 'normal')
benign_path = os.path.join(data_dir, 'benign')
malignant_path = os.path.join(data_dir, 'malignant')

def get_mat_from_images(path, tag, sizex, sizey):
  images = np.sort(os.listdir(path))
  mat = []
  for image in images:
    if image.endswith(').png'):
      #print(image)
      image_data = cv2.resize(cv2.imread(os.path.join(path, image), 0), (sizex, sizey))
      image_data = np.float32(image_data)
      mat.append(image_data)
      #print(image_data.shape)
      #print(image_data.dtype)

  print(f'shape of the {tag} is {np.array(mat).shape}')
  return np.array(mat)

sizex, sizey = 224, 224
normal_mat = get_mat_from_images(normal_path, 'normal', sizex, sizey)
benign_mat = get_mat_from_images(benign_path, 'benign', sizex, sizey)
malignant_mat = get_mat_from_images(malignant_path, 'malignant', sizex, sizey)

plt.imshow(np.squeeze(malignant_mat[179, :, :]), cmap = 'gray')
plt.show()

normal_labels = np.zeros(np.shape(normal_mat)[0])
benign_labels = np.ones(np.shape(benign_mat)[0])
malignant_labels = 2 * np.ones(np.shape(malignant_mat)[0])

# all data
X = np.concatenate((normal_mat, benign_mat, malignant_mat))
#X = np.expand_dims(X, axis = -1)
X = np.repeat(X[..., np.newaxis], 3, -1)
y = np.concatenate((normal_labels, benign_labels, malignant_labels))
print(X.shape, y.shape)
print(np.min(X), np.max(X)) # data is already scaled between 0 and 255

X = vit.preprocess_inputs(X)
print(np.min(X))
print(np.max(X))

resolution = X.shape[1]

IMAGE_SIZE = [resolution, resolution, 3]
NUM_CLASSES = 3

swin_vit = SwinTransformer('swin_large_224', include_top=False, pretrained=True)

model = tf.keras.Sequential()
model.add(tf.keras.Input(shape = IMAGE_SIZE))
model.add(swin_vit)
model.add(tf.keras.layers.Dense(NUM_CLASSES, activation='softmax'))

model.build(IMAGE_SIZE)

#model.build(IMAGE_SIZE)
model.summary()

model.compile(optimizer = tf.keras.optimizers.Adadelta(learning_rate = 0.1), loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])

x_train, x_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)

#print(f'{y_train}')

#print(f'{y_test}')

model.fit(x_train, y_train, batch_size = 8, epochs = 20, validation_split = 0.10)

model.evaluate(x_test, y_test)

y_pred = model.predict(x_test)

y_prob = np.argmax(y_pred, axis = 1)

import sklearn

print(f'Accuracy {sklearn.metrics.accuracy_score(y_test, y_prob)}')
AUC = sklearn.metrics.roc_auc_score(y_test, y_pred, multi_class='ovo')
print(f'AUC is {AUC}')
target_names = ['normal', 'benign', 'malignant']
print('F1-score', sklearn.metrics.f1_score(y_test, y_prob, average = 'micro'))
print(f'Balanced accuracy {sklearn.metrics.balanced_accuracy_score(y_test, y_prob)}')
print(f'MCC {sklearn.metrics.matthews_corrcoef(y_test, y_prob)}')
print(f'{sklearn.metrics.classification_report(y_test, y_prob, target_names=target_names)}')